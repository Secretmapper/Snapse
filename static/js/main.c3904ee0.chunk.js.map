{"version":3,"sources":["components/Layout/index.tsx","components/Graph/useAnimateEdges.ts","utils/classList/index.ts","components/Graph/index.tsx","components/Snapse/index.tsx","automata/snapse/index.ts","components/Snapse/helpers.ts","components/Button/index.tsx","components/Typography/index.tsx","components/App/index.tsx","serviceWorker.ts","index.tsx"],"names":["Layout","props","Container","Side","side","Main","main","styled","div","useAnimateEdges","cyRef","useRef","useEffect","raf","cy","current","animOffset","animate","edges","style","requestAnimationFrame","cancelAnimationFrame","internal","hasClass","orig","className","match","RegExp","has","add","remove","reg","replace","stylesheet","selector","opacity","color","content","events","height","shape","width","ele","data","Graph","setCy","cyCBs","editingRef","editing","elements","id","map","item","classes","classList","onTap","onEdgeCreate","on","evt","edgehandles","handleNodes","preview","loopAllowed","edgeType","sourceNode","targetNode","edgesTo","empty","undefined","complete","src","dst","eles","cxtMenus","cxtMenu","cxtmenu","qId","InputContainer","RulesInput","textarea","SpikeInput","input","Snapse","useState","setEditing","inputRef","cbs","onSurfaceClick","renderedPosition","position","rules","spike","onCreateOutput","setNeurons","neurons","spikes","x","y","isOutput","onEditNode","e","find","el","label","onDeleteNode","newNeurons","onDeleteEdge","source","target","prev","neuron","out","filter","val","cbsRef","useMemo","commands","select","_","addedEles","left","top","onSubmit","preventDefault","spikeValue","parseInt","spikeLabel","isNaN","trim","split","autoFocus","ref","value","onChange","ed","placeholder","type","q1","q2","q3","q4","initializeState","delay","parseRule","rule","res","exec","requires","consumes","produces","delayStr","length","areRulesValid","every","step","prevStates","hasTriggered","newStates","produce","states","spikeAdds","k","state","justResolvedRule","neuronOutKeys","bitstring","createNeuron","time","rootId","parent","createOutput","output","createEdge","Button","button","Typography","p","shortening","keyframes","ProgressBar","isPlaying","css","Title","attrs","as","Subtitle","StepBackButton","PlayButton","StepForwardButton","App","setIsPlaying","initialNeurons","initialize","neuronsState","setNeuronsState","previousNeuronsStateRef","usePrevious","onForward","n","prevState","concat","validRules","neuronCard","join","convert","pBar","setPBar","onIntervalStepRef","interval","setInterval","clearInterval","onClick","key","Boolean","window","location","hostname","cytoscape","use","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.c3904ee0.chunk.js","sourcesContent":["import React from 'react'\nimport styled from 'styled-components'\n\nexport type ILayout = {\n  side: React.ReactElement\n  main: React.ReactElement\n}\n\nfunction Layout(props: ILayout) {\n  return (\n    <Container>\n      <Side>{props.side}</Side>\n      <Main>{props.main}</Main>\n    </Container>\n  )\n}\n\nexport default Layout\n\nconst Container = styled.div`\n  display: flex;\n  flex-direction: row;\n  flex: 1;\n  height: 100%;\n  width: 100%;\n`\nconst Main = styled.div`\n  flex-direction: column;\n  flex: 1;\n  height: 100%;\n`\nconst Side = styled.div`\n  flex-direction: column;\n  flex-shrink: 0;\n  height: 100%;\n  width: 250px;\n  z-index: 2;\n`\n","import { useEffect, useRef } from 'react'\nimport cytoscapejs from 'cytoscape'\n\nfunction useAnimateEdges() {\n  const cyRef = useRef<cytoscapejs.Core | null>(null)\n  const setCy = (internal: cytoscapejs.Core) => {\n    cyRef.current = internal\n  }\n\n  useEffect(() => {\n    const cy = cyRef.current\n    let raf: number\n    let animOffset = 0\n\n    function animate() {\n      animOffset++\n      if (cy) {\n        cy.edges().animate({\n          style: { 'line-dash-offset': -animOffset }\n        })\n      }\n      raf = requestAnimationFrame(animate)\n    }\n\n    animate()\n\n    return () => {\n      if (raf) {\n        cancelAnimationFrame(raf)\n      }\n    }\n  }, [])\n\n  return [cyRef, setCy] as const\n}\n\nexport default useAnimateEdges\n","export function hasClass(orig: string = '', className: string) {\n  return !!orig.match(new RegExp('(\\\\s|^)' + className + '(\\\\s|$)'))\n}\n\nexport function addClass(orig: string = '', className: string) {\n  if (!hasClass(orig, className)) {\n    return orig + ' ' + className\n  }\n  return orig\n}\n\nexport function removeClass(orig: string = '', className: string) {\n  if (hasClass(orig, className)) {\n    var reg = new RegExp('(\\\\s|^)' + className + '(\\\\s|$)')\n    return orig.replace(reg, ' ')\n  }\n  return orig\n}\n\nexport default {\n  has: hasClass,\n  add: addClass,\n  remove: removeClass\n}\n","import React, { useEffect, useRef } from 'react'\nimport cytoscapejs from 'cytoscape'\nimport Cytoscape from 'react-cytoscapejs'\nimport useAnimateEdges from './useAnimateEdges'\nimport classList from '../../utils/classList'\n\ntype IGraph = {\n  elements: cytoscapejs.ElementDefinition[]\n  editing: { id?: string } | null\n  onTap?: (evt: cytoscapejs.EventObject) => void\n  onEdgeCreate?: (\n    src: cytoscapejs.NodeSingular,\n    dst: cytoscapejs.NodeSingular,\n    addedEles: cytoscapejs.EdgeCollection\n  ) => void\n  cxtMenus: CxtMenu[]\n}\ntype CxtMenu = any\n\nfunction Graph(props: IGraph) {\n  const [cyRef, setCy] = useAnimateEdges()\n  const cyCBs = useRef<any>()\n\n  const editingRef = useRef(props.editing)\n\n  let elements = props.elements\n  if (\n    editingRef.current !== props.editing ||\n    (editingRef.current &&\n      props.editing &&\n      editingRef.current.id !== props.editing.id)\n  ) {\n    elements = elements.map(item => {\n      if (props && props.editing) {\n        if (props.editing.id === item.data.id) {\n          item = {\n            ...item,\n            classes: classList.add(item.classes || '', 'node--editing')\n          }\n        } else {\n          item = {\n            ...item,\n            classes: classList.remove(item.classes || '', 'node--editing')\n          }\n        }\n      }\n      return item\n    })\n  }\n\n  cyCBs.current = { onTap: props.onTap, onEdgeCreate: props.onEdgeCreate }\n  useEffect(() => {\n    const cy = cyRef.current\n\n    const onTap = (evt: cytoscapejs.EventObject) => {\n      if (cyCBs.current.onTap) {\n        cyCBs.current.onTap(evt)\n      }\n    }\n    const onEdgeCreate: IGraph['onEdgeCreate'] = (src, dst, eles) => {\n      if (cyCBs.current.onEdgeCreate) {\n        cyCBs.current.onEdgeCreate(src, dst, eles)\n      }\n    }\n    if (cy) {\n      cy.on('tap', onTap)\n\n      // TODO: edgehandles is not generalized\n      cy.edgehandles({\n        handleNodes: '.snapse-node',\n        preview: false,\n        loopAllowed: () => true,\n        edgeType: function (sourceNode, targetNode) {\n          return sourceNode.edgesTo(targetNode).empty() ? 'flat' : undefined\n        },\n        complete: onEdgeCreate\n      })\n    }\n  }, [cyRef])\n  useEffect(() => {\n    const cy = cyRef.current\n    if (cy) {\n      // TODO: cxtMenus is not updated for prop\n      props.cxtMenus.map(cxtMenu => (cy as any).cxtmenu(cxtMenu))\n    }\n  }, [cyRef, props.cxtMenus])\n\n  return (\n    <Cytoscape\n      cy={setCy}\n      elements={elements}\n      style={{ width: '100%', height: '100%' }}\n      stylesheet={stylesheet}\n    />\n  )\n}\n\nconst stylesheet: cytoscapejs.Stylesheet[] = [\n  {\n    selector: '.node--editing',\n    style: {\n      opacity: 0\n    }\n  },\n  {\n    selector: '.snapse-node, .snapse-output',\n    style: {\n      'background-opacity': '0' as any,\n      'padding-top': '0',\n      'border-width': 0,\n      'text-halign': 'left',\n      'text-valign': 'top',\n      color: 'black',\n      content: 'data(label)'\n    }\n  },\n  {\n    selector: '.snapse-node__rules, .snapse-node__output',\n    style: {\n      'background-color': 'white',\n      'border-width': 1,\n      events: 'no',\n      'text-wrap': 'wrap',\n      'text-halign': 'center',\n      'text-valign': 'center',\n      content: 'data(label)',\n      height: 150,\n      shape: 'roundrectangle',\n      width: 100\n    }\n  },\n  {\n    selector: '.snapse-node__rules--invalid',\n    style: {\n      'background-color': '#ffbbbb',\n      'border-color': '#ff4e4d'\n    }\n  },\n  {\n    selector: '.snapse-node__output',\n    style: {\n      height: 50,\n      width: 150\n    }\n  },\n  {\n    selector: '.snapse-node__time, .snapse-node__spike',\n    style: {\n      'background-opacity': '0' as any,\n      'text-halign': 'center',\n      'text-valign': 'center',\n      content: 'data(label)',\n      events: 'no',\n      height: 15,\n      shape: 'roundrectangle',\n      width: 50\n    }\n  },\n  {\n    selector: 'edge',\n    style: {\n      'curve-style': 'bezier',\n      'target-arrow-shape': 'triangle',\n      'text-background-color': 'white',\n      'text-background-shape': 'rectangle',\n      width: 1\n    }\n  },\n  {\n    selector: '.node--value-increase, .node--value-decrease',\n    style: {\n      'transition-property': 'background-opacity',\n      'transition-duration': '0.5s' as any\n    }\n  },\n  {\n    selector: '.node--value-increase',\n    style: {\n      'background-color': '#A4DE02',\n      'background-opacity': 1,\n      content: ele => '▲' + ele.data('label')\n    }\n  },\n  {\n    selector: '.node--value-decrease',\n    style: {\n      'background-color': '#E0371F',\n      'background-opacity': 1,\n      color: 'white',\n      content: ele => '▼' + ele.data('label')\n    }\n  },\n  {\n    selector: '.node--triggering',\n    style: {}\n  },\n  {\n    selector: '.edge--triggering',\n    style: {\n      'line-color': 'darkgreen',\n      'line-style': 'dashed',\n      'target-arrow-color': 'darkgreen',\n      width: 3\n    }\n  }\n]\n\nexport default Graph\n","import React, {\n  Dispatch,\n  SetStateAction,\n  useMemo,\n  useRef,\n  useState\n} from 'react'\nimport cytoscapejs from 'cytoscape'\nimport Graph from '../Graph'\nimport styled from 'styled-components'\nimport { NeuronsMap } from '../../automata/snapse'\n\nlet qId = 5\n\ntype EditingState = {\n  id?: string\n  position: {\n    x: number\n    y: number\n  }\n  renderedPosition: {\n    x: number\n    y: number\n  }\n  rules: string\n  spike: string\n}\n\nexport type ISnapse = {\n  elements: cytoscapejs.ElementDefinition[]\n  setNeurons: Dispatch<SetStateAction<NeuronsMap>>\n}\n\nfunction Snapse(props: ISnapse) {\n  const elements = props.elements\n  const [editing, setEditing] = useState<EditingState | null>(null)\n\n  const inputRef = useRef<HTMLTextAreaElement>(null)\n  const onSubmitForm = (e: React.ChangeEvent<HTMLFormElement>) => {\n    e.preventDefault()\n    if (editing) {\n      const spikeValue = parseInt(editing.spike, 10)\n      const spikeLabel = isNaN(spikeValue) ? 0 : spikeValue\n\n      if (editing.id != null) {\n        const id = editing.id\n        props.setNeurons(neurons => ({\n          ...neurons,\n          [id]: {\n            ...neurons[id],\n            rules: editing.rules.trim().split('\\n'),\n            spikes: spikeLabel\n          }\n        }))\n      } else {\n        // create a new node\n        const id = `q${qId++}`\n        props.setNeurons(neurons => ({\n          ...neurons,\n          [id]: {\n            id,\n            spikes: spikeLabel,\n            position: {\n              x: editing.position.x,\n              y: editing.position.y\n            },\n            rules: editing.rules.trim().split('\\n'),\n            out: [],\n            isOutput: false\n          }\n        }))\n      }\n      setEditing(null)\n    }\n  }\n  const onRulesChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {\n    const rules = e.target.value\n    setEditing(ed => (ed ? { ...ed, rules } : null))\n  }\n  const onSpikeChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const spike = e.target.value\n    setEditing(ed => (ed ? { ...ed, spike } : null))\n  }\n  const onEditNode = (\n    e: cytoscapejs.NodeSingular,\n    evt: cytoscapejs.EventObject\n  ) => {\n    const id = e.id()\n    const rules = elements.find(el => el.data.id === `${id}-rules`)?.data.label\n    const spike = elements.find(el => el.data.id === `${id}-spike`)?.data.label\n\n    setEditing({\n      id,\n      renderedPosition: e.renderedPosition(),\n      position: e.position(),\n      rules,\n      spike\n    })\n  }\n  const onDeleteNode = (id: string) => {\n    props.setNeurons(neurons => {\n      const newNeurons = { ...neurons }\n      delete newNeurons[id]\n      return newNeurons\n    })\n  }\n  const onDeleteEdge = (ele: cytoscapejs.NodeSingular) => {\n    const source = ele.data('source')\n    const target = ele.data('target')\n    props.setNeurons(prev => {\n      const neurons = { ...prev }\n      const neuron = { ...neurons[source] }\n      if (neuron.isOutput === false) {\n        neuron.out = neuron.out.filter(val => val !== target)\n      }\n      return neurons\n    })\n  }\n\n  const onSurfaceClick = (evt: cytoscapejs.EventObject) => {\n    setEditing({\n      renderedPosition: evt.renderedPosition,\n      position: evt.position,\n      rules: '',\n      spike: ''\n    })\n  }\n  const onCreateOutput = (evt: cytoscapejs.EventObject) => {\n    const id = `q${qId++}`\n    props.setNeurons(neurons => ({\n      ...neurons,\n      [id]: {\n        id,\n        spikes: 1,\n        position: {\n          x: evt.position.x,\n          y: evt.position.y\n        },\n        isOutput: true\n      }\n    }))\n  }\n  const onEdgeCreate = (\n    src: cytoscapejs.NodeSingular,\n    dst: cytoscapejs.NodeSingular,\n    addedEles: cytoscapejs.EdgeCollection\n  ) => {\n    const id = src.id()\n    props.setNeurons(prev => {\n      const neurons = { ...prev }\n      const neuron = { ...neurons[id] }\n      if (neuron.isOutput === false) {\n        neuron.out = [...neuron.out, dst.id()]\n      }\n      neurons[id] = neuron\n      return neurons\n    })\n    // let's remove the added elements\n    // and let our passed props recreate it\n    addedEles.remove()\n  }\n\n  const cbs = {\n    onSurfaceClick,\n    onCreateOutput,\n    onEditNode,\n    onDeleteNode,\n    onDeleteEdge\n  }\n  const cbsRef = useRef(cbs)\n  cbsRef.current = cbs\n  const cxtMenus = useMemo(\n    () => [\n      {\n        selector: 'core',\n        commands: [\n          {\n            content: 'Create Node',\n            select: function (_: any, e: cytoscapejs.EventObject) {\n              cbsRef.current.onSurfaceClick(e)\n            }\n          },\n          {\n            content: 'Create Output',\n            select: function (_: any, e: cytoscapejs.EventObject) {\n              cbsRef.current.onCreateOutput(e)\n            }\n          }\n        ]\n      },\n      {\n        selector: 'node',\n        commands: [\n          {\n            content: 'Edit Node',\n            select: function (\n              ele: cytoscapejs.NodeSingular,\n              e: cytoscapejs.EventObject\n            ) {\n              cbsRef.current.onEditNode(ele, e)\n            }\n          },\n          {\n            content: 'Delete Node',\n            select: function (ele: cytoscapejs.NodeSingular) {\n              cbsRef.current.onDeleteNode(ele.id())\n            }\n          }\n        ]\n      },\n      {\n        selector: 'edge',\n        commands: [\n          {\n            content: 'Delete Edge',\n            select: function (ele: cytoscapejs.NodeSingular) {\n              cbsRef.current.onDeleteEdge(ele)\n            }\n          }\n        ]\n      }\n    ],\n    [cbsRef]\n  )\n\n  return (\n    <Container>\n      <Graph\n        elements={props.elements}\n        editing={editing}\n        cxtMenus={cxtMenus}\n        onEdgeCreate={onEdgeCreate}\n      />\n      {editing && (\n        <InputContainer\n          style={{\n            left: editing?.renderedPosition.x,\n            top: editing?.renderedPosition.y\n          }}>\n          <form onSubmit={onSubmitForm}>\n            <div>\n              <label>Rules</label>\n            </div>\n            <div>\n              <RulesInput\n                autoFocus\n                ref={inputRef}\n                value={editing?.rules}\n                onChange={onRulesChange}\n              />\n            </div>\n            <div>\n              <label>Initial Spikes</label>\n            </div>\n            <div>\n              <SpikeInput\n                placeholder=\"0\"\n                type=\"number\"\n                value={editing?.spike}\n                onChange={onSpikeChange}\n              />\n            </div>\n            <div>\n              <button>Save Node</button>\n            </div>\n          </form>\n        </InputContainer>\n      )}\n    </Container>\n  )\n}\n\nconst Container = styled.div`\n  position: relative;\n  flex: 1;\n  width: 100%;\n  height: 100%;\n`\n\nconst InputContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  position: absolute;\n  text-align: center;\n  transform: translate3d(-50%, -50%, 0);\n`\n\nconst RulesInput = styled.textarea`\n  background-color: rgba(244, 244, 244, 1);\n  height: 150px;\n  margin: 2px;\n  outline-width: thin;\n  text-align: center;\n  width: 100px;\n`\n\nconst SpikeInput = styled.input`\n  background-color: rgba(244, 244, 244, 1);\n  margin: 2px;\n  outline-width: thin;\n  text-align: center;\n`\n\nexport default Snapse\n","import produce from 'immer'\n\ntype NeuronID = string\ntype NeuronRule = string\nexport type NeuronState = {\n  spikes: number\n  delay: number\n  bitstring?: string\n  rule?: NeuronRule\n  justResolvedRule?: NeuronRule\n}\n\ntype BaseNeuron = {\n  id: NeuronID\n  spikes: number\n  state?: NeuronState\n  position: { x: number; y: number }\n}\n\ntype NormalNeuron = BaseNeuron & {\n  rules: NeuronRule[]\n  out: NeuronID[]\n  isOutput: false\n}\n\ntype OutputNeuron = BaseNeuron & {\n  isOutput: true\n}\n\ntype Neuron = NormalNeuron | OutputNeuron\nexport type NeuronsMap = {\n  [k: string]: Neuron\n}\nexport type NeuronsStatesMap = {\n  [k: string]: NeuronState\n}\n\nexport const neurons: NeuronsMap = {\n  q1: {\n    id: 'q1',\n    spikes: 2,\n    rules: ['aa/aa->a;1'],\n    out: ['q2'],\n    position: { x: 300, y: 250 },\n    isOutput: false\n  },\n  q2: {\n    id: 'q2',\n    spikes: 2,\n    isOutput: true,\n    position: { x: 600, y: 450 }\n  },\n  q3: {\n    id: 'q3',\n    spikes: 1,\n    rules: ['a/a->a;2'],\n    out: ['q1', 'q4'],\n    position: { x: 100, y: 100 },\n    isOutput: false\n  },\n  q4: {\n    id: 'q4',\n    spikes: 1,\n    rules: ['a/a->a;4'],\n    out: ['q1', 'q3'],\n    position: { x: 100, y: 350 },\n    isOutput: false\n  }\n}\n\n// initialize state\nexport function initialize(neurons: NeuronsMap) {\n  const states: NeuronsStatesMap = {}\n  for (const k in neurons) {\n    const neuron = neurons[k]\n    states[k] = initializeState(neuron)\n  }\n  return states\n}\n\nexport function initializeState(neuron: Neuron) {\n  return {\n    spikes: neuron.spikes,\n    delay: 0\n  }\n}\n\ntype RuleMap = [number, number, number, number]\nexport function parseRule(rule: NeuronRule): RuleMap | false {\n  const re = /(a+)\\/(a+)->(a+);([0-9]+)/\n  const res = re.exec(rule)\n  if (res) {\n    const [, requires, consumes, produces, delayStr] = res\n    const delay = parseInt(delayStr, 10)\n    return [requires.length, consumes.length, produces.length, delay]\n  }\n\n  return false\n}\nexport function areRulesValid(rules: NeuronRule[]) {\n  return rules.every(parseRule)\n}\n\nexport function step(neurons: NeuronsMap, prevStates: NeuronsStatesMap) {\n  // let's us know if we're actually stepping\n  // through or the system has finished\n  let hasTriggered = false\n  const newStates = produce(prevStates, states => {\n    const spikeAdds: { [key: string]: number } = {}\n\n    for (const k in neurons) {\n      const neuron = neurons[k]\n      states[k] = states[k] || initializeState(neuron)\n\n      const state = states[k]\n      delete state.justResolvedRule\n\n      if (!neuron.isOutput) {\n        if (areRulesValid(neuron.rules)) {\n          if (state.delay > 0) {\n            hasTriggered = true\n            state.delay--\n\n            if (state.delay === 0) {\n              // resolve neuron\n              if (state.rule) {\n                const [, consumes, produces] = parseRule(state.rule) as RuleMap\n\n                state.spikes -= consumes\n                state.justResolvedRule = state.rule\n                delete state.rule\n\n                const neuronOutKeys = (neurons[k] as NormalNeuron).out\n                for (let k of neuronOutKeys) {\n                  spikeAdds[k] =\n                    k in spikeAdds ? spikeAdds[k] + produces : produces\n                }\n              }\n            }\n          } else if (state.delay === 0) {\n            if (neuron.out && neuron.out.length > 0) {\n              const rule = neuron.rules[0]\n              const [requires, , , delay] = parseRule(rule) as RuleMap\n\n              if (state.spikes === requires) {\n                hasTriggered = true\n                state.rule = rule\n                state.delay = delay\n              }\n            }\n          }\n        }\n      } else {\n        if (!(k in spikeAdds)) {\n          spikeAdds[k] = 0\n        }\n      }\n    }\n\n    for (const k in spikeAdds) {\n      states[k].spikes += spikeAdds[k]\n      if (k in neurons && neurons[k].isOutput) {\n        states[k].bitstring =\n          (states[k].bitstring || '') + (spikeAdds[k] || '0')\n      }\n    }\n  })\n\n  return hasTriggered ? newStates : prevStates\n}\n\nexport function stepBack(neurons: NeuronsMap, nextStates: NeuronsStatesMap) {\n  // TODO: This produces wrong output if the resolved rules are missing\n  return produce(nextStates, states => {\n    const spikeAdds: { [key: string]: number } = {}\n\n    for (const k in neurons) {\n      const neuron = neurons[k]\n      const state = states[k]\n\n      if (!neuron.isOutput) {\n        if (state.delay === 0) {\n          // resolved neuron\n          if (state.justResolvedRule) {\n            const [, consumes, produces] = parseRule(\n              state.justResolvedRule\n            ) as RuleMap\n            state.spikes += consumes\n            state.rule = state.justResolvedRule\n            state.delay++\n            delete state.justResolvedRule\n\n            const neuronOutKeys = (neurons[k] as NormalNeuron).out\n            for (let k of neuronOutKeys) {\n              spikeAdds[k] = k in spikeAdds ? spikeAdds[k] + produces : produces\n            }\n          }\n        } else if (state.rule) {\n          // running a rule\n          const [, , , delay] = parseRule(state.rule) as RuleMap\n          // it just started running\n          if (state.delay === delay) {\n            delete state.rule\n            state.delay = 0\n          } else {\n            state.delay++\n          }\n        }\n      } else {\n        state.bitstring = state.bitstring?.slice(0, -1)\n        if (state.bitstring?.length === 0) {\n          delete state.bitstring\n        }\n      }\n    }\n\n    for (const k in spikeAdds) {\n      states[k].spikes -= spikeAdds[k]\n    }\n  })\n}\n","import cytoscapejs from 'cytoscape'\n\nexport const createNeuron = (\n  id: string,\n  x: number,\n  y: number,\n  label: string,\n  rules: string,\n  spike: number,\n  time: number,\n  classes: string = ''\n): cytoscapejs.ElementDefinition[] => [\n  {\n    data: { rootId: id, id: `${id}`, label },\n    classes: 'snapse-node',\n    position: { x: 0, y: 0 }\n  },\n  {\n    data: { rootId: id, id: `${id}-rules`, parent: id, label: rules },\n    classes: 'snapse-node__rules',\n    position: { x, y: y }\n  },\n  {\n    data: { rootId: id, id: `${id}-spike`, parent: id, label: spike },\n    classes: 'snapse-node__spike',\n    position: { x, y: y + 60 }\n  },\n  {\n    data: { rootId: id, id: `${id}-time`, parent: id, label: time },\n    classes: 'snapse-node__time',\n    position: { x, y: y + 90 }\n  }\n]\n\nexport const createOutput = (\n  id: string,\n  x: number,\n  y: number,\n  label: string,\n  output: string,\n  spike: number\n): cytoscapejs.ElementDefinition[] => [\n  {\n    data: { rootId: id, id: `${id}`, label },\n    classes: 'snapse-output',\n    position: { x: 0, y: 0 }\n  },\n  {\n    data: { rootId: id, id: `${id}-output`, parent: id, label: output },\n    classes: 'snapse-node__output',\n    position: { x, y: y }\n  },\n  {\n    data: { rootId: id, id: `${id}-spike`, parent: id, label: spike },\n    classes: 'snapse-node__spike',\n    position: { x, y: y + 40 }\n  }\n]\n\nexport const createEdge = (source: string, target: string) => [\n  {\n    data: {\n      id: `${source}-${target}`,\n      source,\n      target\n    },\n    classes: ''\n  }\n]\n","import styled from 'styled-components'\n\nconst Button = styled.button`\n  background-color: #007bff;\n  border-color: #007bff;\n  border-radius: 4px;\n  border: 0;\n  color: #fff;\n  cursor: pointer;\n  display: block;\n  font-size: 14px;\n  margin-bottom: 4px;\n  padding: 8px;\n  text-transform: uppercase;\n  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out,\n    border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;\n  width: 100%;\n  &:hover {\n    color: #fff;\n    background-color: #0069d9;\n    border-color: #0062cc;\n  }\n  &:focus {\n    box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.5);\n  }\n  &:active {\n    background-color: #0062cc;\n    border-color: #005cbf;\n  }\n`\n\nexport default Button\n","import styled from 'styled-components'\n\nconst Typography = styled.p`\n  font-family: montserrat;\n  font-weight: 400;\n`\n\nexport default Typography\n","import React, { useEffect, useMemo, useRef, useState } from 'react'\nimport cytoscapejs from 'cytoscape'\nimport styled, { css, keyframes } from 'styled-components'\nimport Layout from '../Layout'\nimport Snapse from '../Snapse'\nimport {\n  initialize,\n  initializeState,\n  neurons as initialNeurons,\n  NeuronState,\n  NeuronsMap,\n  NeuronsStatesMap,\n  step,\n  stepBack,\n  areRulesValid\n} from '../../automata/snapse'\nimport { createEdge, createNeuron, createOutput } from '../Snapse/helpers'\nimport classList from '../../utils/classList'\nimport Button from '../Button'\nimport Typography from '../Typography'\n\nfunction convert(\n  neurons: NeuronsMap,\n  neuronsState: NeuronsStatesMap,\n  prevStates: NeuronsStatesMap = {}\n): cytoscapejs.ElementDefinition[] {\n  let elements: cytoscapejs.ElementDefinition[] = []\n\n  for (let k in neurons) {\n    const neuron = neurons[k]\n    const state: NeuronState = neuronsState[k] || initializeState(neuron)\n    const prevState = prevStates[neuron.id]\n\n    if (!neuron.isOutput) {\n      const validRules = areRulesValid(neuron.rules)\n      const neuronCard = createNeuron(\n        neuron.id,\n        neuron.position.x,\n        neuron.position.y,\n        neuron.id,\n        neuron.rules.join('\\n'),\n        state.spikes,\n        state.delay\n      )\n      if (!validRules) {\n        neuronCard[1].classes = classList.add(\n          neuronCard[1].classes,\n          'snapse-node__rules--invalid'\n        )\n      }\n      if (prevState) {\n        if (prevState.spikes < state.spikes) {\n          neuronCard[2].classes = classList.add(\n            neuronCard[2].classes,\n            'node--value-increase'\n          )\n        } else if (prevState.spikes > state.spikes) {\n          neuronCard[2].classes = classList.add(\n            neuronCard[2].classes,\n            'node--value-decrease'\n          )\n        }\n\n        if (prevState.delay < state.delay) {\n          neuronCard[3].classes = classList.add(\n            neuronCard[3].classes,\n            'node--value-increase'\n          )\n        } else if (prevState.delay > state.delay) {\n          neuronCard[3].classes = classList.add(\n            neuronCard[3].classes,\n            'node--value-decrease'\n          )\n        }\n      }\n      if (state.justResolvedRule) {\n        neuronCard[1].classes = classList.add(\n          neuronCard[1].classes,\n          'node--triggering'\n        )\n      }\n      elements = elements.concat(neuronCard)\n      if (neuron.out) {\n        for (let out of neuron.out) {\n          const edges = createEdge(neuron.id, out)\n          if (state.justResolvedRule) {\n            edges[0].classes = classList.add(\n              edges[0].classes,\n              'edge--triggering'\n            )\n          }\n          elements = elements.concat(edges)\n        }\n      }\n    } else {\n      elements = elements.concat(\n        createOutput(\n          neuron.id,\n          neuron.position.x,\n          neuron.position.y,\n          neuron.id,\n          state.bitstring || '',\n          state.spikes\n        )\n      )\n    }\n  }\n\n  return elements\n}\n\nfunction usePrevious<T>(value: T) {\n  const ref = useRef<T>()\n  useEffect(() => {\n    ref.current = value\n  })\n  return ref\n}\n\nfunction App() {\n  const [isPlaying, setIsPlaying] = useState(false)\n  const [neurons, setNeurons] = useState(initialNeurons)\n  const [neuronsState, setNeuronsState] = useState(() => initialize(neurons))\n  const previousNeuronsStateRef = usePrevious(neuronsState)\n\n  const onTogglePlay = () => {\n    setIsPlaying(p => !p)\n  }\n  const onBack = (n: NeuronsMap = neurons) => {\n    // setNeuronsState(neuronsState => stepBack(n, neuronsState))\n  }\n  const onForward = (n: NeuronsMap = neurons) => {\n    setNeuronsState(neuronsState => step(n, neuronsState))\n  }\n  const elements = useMemo(\n    () => convert(neurons, neuronsState, previousNeuronsStateRef.current),\n    [neurons, neuronsState, previousNeuronsStateRef]\n  )\n\n  const [pBar, setPBar] = useState(0)\n  const neuronsRef = useRef(neurons)\n  neuronsRef.current = neurons\n  const onIntervalStepRef = useRef(onForward)\n  onIntervalStepRef.current = () => {\n    onForward(neurons)\n    setPBar(p => p + 1)\n  }\n  useEffect(() => {\n    let interval: NodeJS.Timeout\n\n    if (isPlaying) {\n      interval = setInterval(() => {\n        onIntervalStepRef.current()\n      }, 1000)\n    }\n\n    return () => clearInterval(interval)\n  }, [isPlaying, onIntervalStepRef])\n\n  return (\n    <Layout\n      main={<Snapse elements={elements} setNeurons={setNeurons} />}\n      side={\n        <Container>\n          <Title>Snapse</Title>\n          <Subtitle>\n            Modern Spiking Neural P systems Maker and Visualizer\n          </Subtitle>\n          <StepBackButton onClick={() => onBack()}>Back</StepBackButton>\n          <ProgressBar key={pBar} isPlaying={isPlaying} />\n          <PlayButton onClick={onTogglePlay}>\n            {isPlaying ? 'Pause' : 'Play'}\n          </PlayButton>\n          <StepForwardButton onClick={() => onForward()}>\n            Forward\n          </StepForwardButton>\n        </Container>\n      }\n    />\n  )\n}\n\nconst shortening = keyframes`\n  from {\n    transform: scaleX(100%);\n  }\n\n  to {\n    transform: scaleX(0%);\n  }\n`\nconst ProgressBar = styled.div<{ isPlaying: boolean }>`\n  ${props =>\n    props.isPlaying &&\n    css`\n      animation: ${shortening} 1s linear;\n    `}\n  background-color: red;\n  height: 4px;\n  transform-origin: left center;\n  width: 100%;\n`\n\nconst Container = styled.div`\n  border-style: solid;\n  border-width: 0;\n  border-right-width: 1px;\n  border-color: #e1e4e8;\n  padding: 20px;\n  height: 100%;\n`\nconst Title = styled(Typography).attrs(() => ({ as: 'h1' }))`\n  margin: 0;\n  text-align: center;\n`\nconst Subtitle = styled(Typography).attrs(() => ({ as: 'h3' }))`\n  font-size: 13px;\n  text-align: center;\n  margin-top: 4px;\n  margin-bottom: 8px;\n`\nconst StepBackButton = styled(Button)``\nconst PlayButton = styled(Button)``\nconst StepForwardButton = styled(Button)``\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n)\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void\n  onUpdate?: (registration: ServiceWorkerRegistration) => void\n}\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href)\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config)\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          )\n        })\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config)\n      }\n    })\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing\n        if (installingWorker == null) {\n          return\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              )\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration)\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.')\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration)\n              }\n            }\n          }\n        }\n      }\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error)\n    })\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type')\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload()\n          })\n        })\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config)\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      )\n    })\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister()\n      })\n      .catch(error => {\n        console.error(error.message)\n      })\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './components/App'\nimport * as serviceWorker from './serviceWorker'\n\nimport 'typeface-montserrat'\nimport cytoscape from 'cytoscape'\nimport cxtmenu from 'cytoscape-cxtmenu'\nimport edgehandles from 'cytoscape-edgehandles'\n\ncytoscape.use(cxtmenu)\ncytoscape.use(edgehandles as any)\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}